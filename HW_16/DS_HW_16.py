# -*- coding: utf-8 -*-
"""DS_HW_16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eIo6qLrk16l2a-hfVc0eA4meRjGl7RU_

# Homework DS 16

Вам необхідно буде побудувати веб-застосунок для візуалізації роботи вашої нейронної мережі за допомогою Streamlit або Dash. В якості домашнього завдання ви можете продовжити домашнє завдання для модуля “Згорткові нейронні мережі”.



Завдання


    Створіть веб-застосунок, який дозволяє завантажувати зображення для класифікації за допомогою вашої навченої нейронної мережі.
    Відобразіть вхідне зображення на веб-сторінці.
    Виведіть графіки функції втрат і точності для моделі; результати класифікації (ймовірності для кожного класу та передбачений клас) у зручному форматі.
    Додайте інтерфейс для вибору між двома моделями (згорткова нейромережа з Частини 1 і модель на основі VGG16 з Частини 2).



Необхідний функціонал:


- Інтерфейс для завантаження зображення, яке користувач хоче класифікувати.

- Використання завантаженої моделі для передбачення класу завантаженого зображення.
"""

# -*- coding: utf-8 -*-
import numpy as np
import cv2
import tensorflow as tf
from tensorflow.keras.models import load_model, Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
from tensorflow.keras.preprocessing import image
import streamlit as st
import matplotlib.pyplot as plt
import os

# Функція для передобробки зображення
def preprocess_image(uploaded_image):
    if uploaded_image is None:
        st.error("Будь ласка, завантажте зображення.")
        return None

    file_bytes = np.asarray(bytearray(uploaded_image.read()), dtype=np.uint8)
    img = cv2.imdecode(file_bytes, cv2.IMREAD_COLOR)

    if img is None:
        st.error("Не вдалося обробити зображення.")
        return None

    img = cv2.resize(img, (224, 224))
    img_array = np.array(img) / 255.0
    img_array = np.expand_dims(img_array, axis=0)
    return img_array

# Створення базової моделі CNN
def create_cnn_model():
    model = Sequential([
        Conv2D(32, (3, 3), activation='relu', input_shape=(224, 224, 3)),
        MaxPooling2D(pool_size=(2, 2)),
        Flatten(),
        Dense(128, activation='relu'),
        Dense(10, activation='softmax')  # Вихідний шар для 10 класів
    ])
    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
    return model

# Завантаження обраної моделі
def load_chosen_model(model_name):
    if model_name == "CNN Model":
        return create_cnn_model()
    elif model_name == "VGG16":
        return tf.keras.applications.VGG16(weights='imagenet')
    else:
        raise ValueError("Невірний вибір моделі.")

# Передбачення класу
def predict_image(model, uploaded_image):
    processed_image = preprocess_image(uploaded_image)
    if processed_image is None:
        return None

    predictions = model.predict(processed_image)
    return predictions

# Візуалізація графіків
def plot_metrics(history):
    fig, axs = plt.subplots(1, 2, figsize=(10, 4))

    # Графік втрат
    axs[0].plot(history['loss'], label='Тренувальні втрати')
    axs[0].plot(history['val_loss'], label='Валідаційні втрати')
    axs[0].set_title('Функція втрат')
    axs[0].set_xlabel('Епохи')
    axs[0].set_ylabel('Втрати')
    axs[0].legend()

    # Графік точності
    axs[1].plot(history['accuracy'], label='Тренувальна точність')
    axs[1].plot(history['val_accuracy'], label='Валідаційна точність')
    axs[1].set_title('Точність')
    axs[1].set_xlabel('Епохи')
    axs[1].set_ylabel('Точність')
    axs[1].legend()

    st.pyplot(fig)

# Основна функція
def main():
    st.title("Класифікація зображень з використанням нейронних мереж")

    # Вибір моделі
    model_choice = st.selectbox("Виберіть модель", ["CNN Model", "VGG16"])
    model = load_chosen_model(model_choice)

    # Завантаження зображення
    uploaded_image = st.file_uploader("Завантажте зображення для класифікації", type=["jpg", "png", "jpeg"])

    if uploaded_image is not None:
        st.image(uploaded_image, caption="Завантажене зображення", use_column_width=True)

        # Передбачення
        predictions = predict_image(model, uploaded_image)
        if predictions is not None:
            st.subheader("Результати класифікації")
            for i, score in enumerate(predictions[0]):
                st.write(f"Клас {i}: {score:.4f}")
            predicted_class = np.argmax(predictions[0])
            st.success(f"Передбачений клас: {predicted_class}")

    # Візуалізація графіків
    st.subheader("Графіки навчання моделі")
    dummy_history = {
        'loss': [0.9, 0.6, 0.4, 0.3],
        'val_loss': [1.0, 0.8, 0.6, 0.5],
        'accuracy': [0.7, 0.8, 0.9, 0.95],
        'val_accuracy': [0.6, 0.7, 0.8, 0.85]
    }
    plot_metrics(dummy_history)

if __name__ == "__main__":
    main()

